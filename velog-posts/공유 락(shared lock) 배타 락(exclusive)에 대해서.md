<h1 id="🔒-dbms-트랜잭션의-락과-데드락-정리">🔒 DBMS 트랜잭션의 락과 데드락 정리</h1>
<p>DBMS에서 트랜잭션을 특별한 제어 없이 병행 수행을 허용한다면 데이터의 일관성과 무결성을 보장하기 어려울 수 있습니다.<br />이때, 병행 수행되는 트랜잭션들을 제어하기 위해서 <strong>락(Lock)</strong> 을 사용할 수 있으며 DBMS에서 락은 크게 <strong>공유 락</strong>과 <strong>배타 락</strong>으로 분류할 수 있습니다.</p>
<hr />
<h3 id="🔒-공유-락shared-lock">🔒 공유 락(Shared Lock)</h3>
<p>읽기 락(Read Lock)이라고도 부르며,<br />공유 락이 걸린 데이터에 대해서는 다른 트랜잭션에서도 공유 락을 획득할 수 있지만, <strong>배타 락은 획득할 수 없습니다.</strong><br />즉, 공유 락을 사용하면 트랜잭션 내에서 <strong>조회한 데이터가 변경되지 않는다는 것</strong>을 보장합니다.</p>
<pre><code class="language-sql">SELECT * FROM table_name WHERE id = 1 FOR SHARE;</code></pre>
<h3 id="🔐-배타-락exclusive-lock">🔐 배타 락(Exclusive Lock)</h3>
<p>쓰기 락(Write Lock)이라고도 부르며,
배타 락이 걸린 데이터에 대해서는 다른 트랜잭션에서는 공유 락과 배타 락을 모두 획득할 수 없습니다.
즉, 배타 락을 획득한 트랜잭션은 해당 데이터에 대한 독점권을 가집니다.</p>
<pre><code class="language-sql">SELECT * FROM table_name WHERE id = 1 FOR UPDATE;</code></pre>
<hr />
<h3 id="✅-정리">✅ 정리</h3>
<ul>
<li>공유 락이 걸린 데이터 → 다른 트랜잭션에서도 공유 락 획득 가능</li>
<li>배타 락이 걸린 데이터 → 다른 트랜잭션에서는 어떤 락도 획득 불가, 대기 발생 가능</li>
</ul>
<hr />
<h3 id="😵-데드-락은-언제-발생하며-어떻게-해결할-수-있나요">😵 데드 락은 언제 발생하며 어떻게 해결할 수 있나요?</h3>
<h4 id="🧱-데드-락dead-lock">🧱 데드 락(Dead Lock)</h4>
<p>두 개 이상의 트랜잭션이 서로 필요한 데이터의 락을 점유하고 있어
무한히 대기하게 되는 교착 상태를 말합니다.
트랜잭션은 락을 획득하지 못하면
다른 트랜잭션이 점유하고 있는 락이 해제될 때까지 대기합니다.</p>
<p>예시 상황:</p>
<ul>
<li>트랜잭션 A, B가 있고, id가 1, 2인 데이터가 있음</li>
<li>트랜잭션 A는 id 1번을 읽고, 2번을 변경</li>
<li>트랜잭션 B는 id 2번을 읽고, 1번을 변경</li>
</ul>
<hr />
<h3 id="❗데드-락-발생-조건">❗데드 락 발생 조건</h3>
<ul>
<li>A는 1번, B는 2번 데이터에 대해 공유 락을 획득</li>
<li>A는 2번 데이터의 락을 점유 중인 B가 락을 해제할 때까지 대기</li>
<li>B는 1번 데이터의 락을 점유 중인 A가 락을 해제할 때까지 대기</li>
<li><blockquote>
<p>서로가 서로를 기다리며 무한 대기, 데드락 발생</p>
</blockquote>
</li>
</ul>
<hr />
<h3 id="🛠-데드-락-해결-방법">🛠 데드 락 해결 방법</h3>
<ul>
<li>락 획득 순서를 일관되게 유지
  모든 트랜잭션이 항상 1번 → 2번 데이터 순으로 락을 획득</li>
<li>락 타임아웃(lock timeout) 설정
  일정 시간 안에 락 획득 실패 시, 트랜잭션 강제 종료 또는 롤백</li>
</ul>