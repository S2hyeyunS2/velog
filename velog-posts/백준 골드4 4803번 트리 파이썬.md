<p><a href="https://www.acmicpc.net/problem/4803">ë°±ì¤€ 4803ë²ˆ íŠ¸ë¦¬</a></p>
<h3 id="âœ”ï¸ë¬¸ì œ">âœ”ï¸<strong>ë¬¸ì œ</strong></h3>
<p><img alt="" src="https://velog.velcdn.com/images/hyeyun98/post/365f7b43-433e-4f89-9477-ba757387d2f7/image.png" /></p>
<hr />
<h3 id="ğŸ“ì•Œê³ ë¦¬ì¦˜">ğŸ“<strong>ì•Œê³ ë¦¬ì¦˜</strong></h3>
<p>ê·¸ë˜í”„, íŠ¸ë¦¬, ê¹Šì´ìš°ì„ íƒìƒ‰</p>
<hr />
<h3 id="ğŸ“Œ-ë¬¸ì œ-íƒìƒ‰í•˜ê¸°"><strong>ğŸ“Œ ë¬¸ì œ íƒìƒ‰í•˜ê¸°</strong></h3>
<ol>
<li>ì–‘ë°©í–¥ ê·¸ë˜í”„ì´ë¯€ë¡œ ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¡œ ì €ì¥</li>
<li>ì—°ê²° ìš”ì†Œ íƒìƒ‰ì„ ìœ„í•œ ë°©ë¬¸ ë°°ì—´ ì‚¬ìš©</li>
<li>DFS/BFSë¥¼ ì´ìš©í•˜ì—¬ ì—°ê²° ìš”ì†Œë¥¼ íƒìƒ‰</li>
<li>ì¶œë ¥ ì¡°ê±´ì— ë”°ë¼ ë¬¸ì¥ ì¶œë ¥</li>
</ol>
<p><strong>âœ… ì…ë ¥ ì¡°ê±´</strong></p>
<ol>
<li>ë…¸ë“œ ê°œìˆ˜ N (0 â‰¤ N â‰¤ 500)</li>
<li>ê°„ì„  ê°œìˆ˜ M (0 â‰¤ M â‰¤ N(N-1)/2)</li>
</ol>
<p><strong>âœ… ì¶œë ¥ ì¡°ê±´</strong></p>
<ol>
<li>íŠ¸ë¦¬ ê°œìˆ˜ê°€ 0ì´ë©´ &quot;No trees.&quot; ì¶œë ¥</li>
<li>íŠ¸ë¦¬ ê°œìˆ˜ê°€ 1ì´ë©´ &quot;There is one tree.&quot; ì¶œë ¥</li>
<li>íŠ¸ë¦¬ ê°œìˆ˜ê°€ 2ê°œ ì´ìƒì´ë©´ &quot;A forest of x trees.&quot; ì¶œë ¥</li>
</ol>
<hr />
<h3 id="âœ”ï¸check"><strong>âœ”ï¸Check</strong></h3>
<ul>
<li>graphë¥¼ ì‚¬ìš©í•´ì„œ ë©”ëª¨ë¦¬ ì ˆì•½</li>
<li>íƒìƒ‰ ì¤‘ ì‚¬ì´í´ì´ ì—†ì„ ë•ŒëŠ” íŠ¸ë¦¬ë¡œ ê°„ì£¼</li>
</ul>
<p><strong>ìµœì¢… ì‹œê°„ë³µì¡ë„ : O(N + M)</strong></p>
<ul>
<li>O(N + M) -&gt; DFS/BFSë¥¼ í•œë²ˆì— ìˆ˜í–‰</li>
</ul>
<hr />
<h3 id="ğŸ“Œ-ì½”ë“œ-ì„¤ê³„í•˜ê¸°"><strong>ğŸ“Œ ì½”ë“œ ì„¤ê³„í•˜ê¸°</strong></h3>
<ol>
<li>ì–‘ë°©í–¥ ê°„ì„ ìœ¼ë¡œ ê·¸ë˜í”„ ì €ì¥</li>
<li>DFSë¥¼ ì‚¬ìš©í•´ì„œ íŠ¸ë¦¬ ê°œìˆ˜ë¥¼ ì„¸ê¸°, ì‚¬ì´í´ì´ ì—†ëŠ” ê²½ìš° íŠ¸ë¦¬ ê°œìˆ˜ +1</li>
<li>íŠ¸ë¦¬ê°œìˆ˜ì— ë”°ë¼ì„œ ì¶œë ¥ í˜•ì‹ ë§ì¶”ê¸°</li>
</ol>
<h3 id="ğŸ–¥ï¸ë‚´ê°€-í‘¼-ì½”ë“œ"><strong>ğŸ–¥ï¸ë‚´ê°€ í‘¼ ì½”ë“œ</strong></h3>
<pre><code class="language-python">import sys

sys.setrecursionlimit(10000)
input = sys.stdin.readline

def dfs(node, parent):
    global cycle
    visited[node] = True
    for neighbor in graph[node]:
        if not visited[neighbor]:
            if not dfs(neighbor, node):
                return False
        elif neighbor != parent:
            cycle = True
    return True

case_num = 0
while True:
    # ì…ë ¥ ë°›ê¸°
    n, m = map(int, input().split())
    if n == 0 and m == 0:  # ì…ë ¥ ì¢…ë£Œ ì¡°ê±´
        break

    graph = [[] for _ in range(n + 1)]
    visited = [False] * (n + 1)

    # ê·¸ë˜í”„ ì…ë ¥ (ì–‘ë°©í–¥)
    for _ in range(m):
        u, v = map(int, input().split())
        graph[u].append(v)
        graph[v].append(u)

    tree_count = 0
    case_num += 1

    # DFSë¡œ íŠ¸ë¦¬ ê°œìˆ˜ íƒìƒ‰
    for i in range(1, n + 1):
        if not visited[i]:
            cycle = False
            if dfs(i, -1) and not cycle:
                tree_count += 1

    # ì¶œë ¥ ì¡°ê±´
    if tree_count == 0:
        print(f&quot;Case {case_num}: No trees.&quot;)
    elif tree_count == 1:
        print(f&quot;Case {case_num}: There is one tree.&quot;)
    else:
        print(f&quot;Case {case_num}: A forest of {tree_count} trees.&quot;)


</code></pre>
<h3 id="âœï¸-ìµœì¢…-ì •ë¦¬">âœï¸ ìµœì¢… ì •ë¦¬</h3>
<table>
<thead>
<tr>
<th>í•­ëª©</th>
<th>ë‚´ìš©</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ë¬¸ì œ í•´ê²° ë°©ë²•</strong></td>
<td>DFSë¥¼ í™œìš©í•˜ì—¬ ì—°ê²° ìš”ì†Œ íƒìƒ‰ ë° ì‚¬ì´í´ íŒë³„</td>
</tr>
<tr>
<td><strong>ì‹œê°„ ë³µì¡ë„</strong></td>
<td><code>O(N + M)</code>, ê·¸ë˜í”„ ì „ì²´ íƒìƒ‰</td>
</tr>
<tr>
<td><strong>í•µì‹¬ ê°œë…</strong></td>
<td>íŠ¸ë¦¬ì˜ ì •ì˜ (ì‚¬ì´í´ ì—†ëŠ” ì—°ê²° ê·¸ë˜í”„), DFS íƒìƒ‰</td>
</tr>
<tr>
<td><strong>ì‚¬ìš© ì•Œê³ ë¦¬ì¦˜</strong></td>
<td><code>DFS</code>, <code>BFS</code>, <code>ì‚¬ì´í´ íŒë³„</code></td>
</tr>
</tbody></table>
<hr />
<h3 id="ğŸ–¥ï¸ë‹¤ë¥¸ì‚¬ëŒ-ì½”ë“œbfs"><strong>ğŸ–¥ï¸ë‹¤ë¥¸ì‚¬ëŒ ì½”ë“œ(BFS)</strong></h3>
<pre><code class="language-python">import sys
from collections import deque
input = sys.stdin.readline
sys.setrecursionlimit(10**9)

# start ë…¸ë“œë¶€í„° ì‹œì‘í•˜ì—¬ BFSë¥¼ ëê¹Œì§€ ëŒê³ 
# ì‚¬ì´í´ ì¡´ì¬ ì—¬ë¶€ë¥¼ ë¦¬í„´í•˜ëŠ” í•¨ìˆ˜
def findCycle(start):
    isCycle = False
    q = deque()
    q.append(start)

    while q:
        cnt_node = q.popleft()
        # ë…¸ë“œë¥¼ íì—ì„œ ë½‘ì•˜ì„ ë•Œ visitedë¥¼ ê°±ì‹ í•´ì¤Œ.
        # ì´ ë•Œ, ë½‘ì€ ë…¸ë“œì˜ visitedê°€ ì´ë¯¸ 1ì¸ ê²½ìš°ëŠ”
        # ì‚¬ì´í´ì´ ì¡´ì¬í•œë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•¨
        # ì˜ˆë¥¼ ë“¤ì–´, 1-2, 2-3, 3-1ì¸ ì‚¬ì´í´ì´ ìˆë‹¤ê³  ìƒê°í•´ë³´ì.
        # 1ì—ì„œ 2ì™€ 3ì„ íì— ë„£ê³  1ì˜ visitedëŠ” 1ì´ ëœë‹¤.
        # ê·¸ ë‹¤ìŒ 2ë¥¼ íì—ì„œ ë½‘ê³ , visitedë¥¼ 1ë¡œ í•œ ë‹¤ìŒ
        # 3ì„ íì— ë„£ëŠ”ë‹¤(ì•„ì§ 1ì—ì„œ ë„£ì€ 3ì´ ë½‘ê¸° ì „ì´ë¯€ë¡œ visitedê°€ 0)
        # ê·¸ ë‹¤ìŒ 1ì—ì„œ ë„£ì€ 3ì„ íì—ì„œ ë½‘ê³  visitedì— 1ì„ ë„£ëŠ”ë‹¤.
        # ì´ì œ íì—ëŠ” 2ì—ì„œ ë„£ì€ 3ì´ ì•„ì§ ë‚¨ì•„ìˆë‹¤. ì´ ê²ƒì„ ë½‘ì•˜ì„ ë•Œ
        # visited[3]ì´ ì´ë¯¸ 1ì´ë¯€ë¡œ ì‚¬ì´í´ë¡œ íŒì •
        if visited[cnt_node]:
            isCycle = True

        visited[cnt_node] = 1

        for adj_node in graph[cnt_node]:
            if visited[adj_node] == 0:
                q.append(adj_node)

    return isCycle

n, m = map(int, input().split())
case = 1

while n != 0 or m != 0:
    graph = [[] for _ in range(n+1)]
    visited = [0]*(n+1)
    count = 0

    # ì–‘ë°©í–¥ ë§¤í•‘
    for _ in range(m):
        a, b = map(int, input().split())
        graph[a].append(b)
        graph[b].append(a)

    # visitedê°€ 0ì¸ ëª¨ë“  ë…¸ë“œë¥¼ ëŒë©´ì„œ
    # ê°€ëŠ¥í•œ ëª¨ë“  ì—°ê²° ìš”ì†Œ(ì—°ê²° ê·¸ë˜í”„)ë¥¼ ìˆœíšŒí•¨
    for node in range(1, n+1):
        if visited[node] == 0:
            if not findCycle(node):
                count += 1

    if count == 0:
        print(f'Case {case}: No trees.')
    elif count == 1:
        print(f'Case {case}: There is one tree.')
    else:
        print(f'Case {case}: A forest of {count} trees.')

    case += 1
    n, m = map(int, input().split())</code></pre>
<h3 id="ğŸ–¥ï¸ë‹¤ë¥¸ì‚¬ëŒ-ì½”ë“œdfs"><strong>ğŸ–¥ï¸ë‹¤ë¥¸ì‚¬ëŒ ì½”ë“œ(DFS)</strong></h3>
<pre><code class="language-python">import sys
input = sys.stdin.readline

# start ë…¸ë“œë¶€í„° ì‹œì‘í•˜ì—¬ DFSë¥¼ ëê¹Œì§€ ëŒê³ 
# ì‚¬ì´í´ ì¡´ì¬ ì—¬ë¶€ë¥¼ ë¦¬í„´í•˜ëŠ” í•¨ìˆ˜
def findCycle(start):
    for adj_node in graph[start]:
        # ì¸ì ‘ ë…¸ë“œê°€ ìì‹ ì˜ ë¶€ëª¨ ë…¸ë“œì¸ ê²½ìš° íŒ¨ìŠ¤
        if parent[start] == adj_node:
            continue

        # ì¸ì ‘ ë…¸ë“œê°€ ë¶€ëª¨ ë…¸ë“œê°€ ì•„ë‹Œë° ë°©ë¬¸ ì´ë ¥ì´
        # ìˆë‹¤ëŠ” ê²ƒì€ ê³§ ì‚¬ì´í´ì„ ì˜ë¯¸í•¨
        if visited[adj_node]:
            return True

        parent[adj_node] = start
        visited[adj_node] = 1
        # ì¸ì ‘ ë…¸ë“œë¥¼ ë£¨íŠ¸ ë…¸ë“œë¡œ í•˜ëŠ” ì„œë¸ŒíŠ¸ë¦¬ì—
        # ì‚¬ì´í´ì´ ì¡´ì¬í•˜ë©´ ê³§ ì „ì²´ íŠ¸ë¦¬ì— ì‚¬ì´í´ì´
        # ì¡´ì¬í•˜ëŠ” ê²ƒê³¼ ê°™ìŒ
        if findCycle(adj_node):
            return True

    return False

n, m = map(int, input().split())
case = 1

while n != 0 or m != 0:
    graph = [[] for _ in range(n+1)]
    parent = [-1]*(n+1)
    visited = [0]*(n+1)
    count = 0

    # ì–‘ë°©í–¥ ë§¤í•‘
    for _ in range(m):
        a, b = map(int, input().split())
        graph[a].append(b)
        graph[b].append(a)

    # visitedê°€ 0ì¸ ëª¨ë“  ë…¸ë“œë¥¼ ëŒë©´ì„œ
    # ê°€ëŠ¥í•œ ëª¨ë“  ì—°ê²° ìš”ì†Œ(ì—°ê²° ê·¸ë˜í”„)ë¥¼ ìˆœíšŒí•¨
    for node in range(1, n+1):
        if visited[node] == 0:
            parent[node] = node
            visited[node] = 1
            if not findCycle(node):
                count += 1

    if count == 0:
        print(f'Case {case}: No trees.')
    elif count == 1:
        print(f'Case {case}: There is one tree.')
    else:
        print(f'Case {case}: A forest of {count} trees.')

    case += 1
    n, m = map(int, input().split()) 
</code></pre>
<hr />
<p><strong>ğŸ“Œ íšŒê³ </strong>
ì´ë²ˆë„ í˜¼ìì˜ í˜ìœ¼ë¡œ í’€ì§€ ëª»í•¨ ã…‹ã…‹ã…ã…</p>